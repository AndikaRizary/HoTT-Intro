\chapter{Inductive types}

\section{The idea of inductive types}

Many other types can also be specified as inductive types, similar to the natural numbers. The unit type, the empty type, and the booleans are the simplest examples of this way of defining types. Just like the type of natural numbers, other inductive types are also specified by their \emph{constructors}, an \emph{induction principle}, and their \emph{computation rules}: 
\begin{enumerate}
\item The constructors tell what structure the inductive type comes equipped with. There may be multiple constructors, or no constructors at all in the specification of an inductive type. 
\item The induction principle specifies the data that should be provided in order to construct a section of an arbitrary dependent type over the inductive type. 
\item The computation rules assert that the inductively defined section agrees on the constructors with the data that was used to define the section. Thus, there is a computation rule for every constructor.
\end{enumerate}
For a more general treatment of inductive types, we refer to Chapter 5 of \cite{hottbook}.
\begin{defn}
We define the \define{unit type} to be a type $\unit$ equipped with
\begin{equation*}
\ttt:\unit,
\end{equation*}
satisfying the induction principle that for any type family $P:\unit\to\type$, there is a term
\begin{equation*}
\ind{\unit} : P(\ttt)\to\prd{x:\unit}P(x)
\end{equation*}
for which the computation rule
\begin{equation*}
\ind{\unit}(p_{\ttt},\ttt) \jdeq p_\ttt
\end{equation*}
holds.
\end{defn}

The empty type is a degenerate example of an inductive type. It does \emph{not} come equipped with any constructors, and therefore there are also no computation rules. The induction principle merely asserts that any type family has a section.
\begin{defn}
We define the \define{empty type} to be a type $\emptyt$ satisfying the induction principle that for any type family $P:\emptyt\to\type$, there is a term
\begin{equation*}
\ind{\emptyt} : \prd{x:\emptyt}P(x).
\end{equation*}
\end{defn}

\begin{defn}
We define the \define{booleans} to be a type $\bool$ that comes equipped with
\begin{align*}
\bfalse & : \bool \\
\btrue & : \bool
\end{align*}
satisfying the induction principle that for any type family $P:\bool\to\type$, there is a term
\begin{equation*}
\ind{\bool} : P(\bfalse)\to P(\btrue)\to \prd{x:\bool}P(x)
\end{equation*}
for which the computation rules
\begin{align*}
\ind{\bool}(p_0,p_1,\bfalse) & \jdeq p_0 \\
\ind{\bool}(p_0,p_1,\btrue) & \jdeq p_1
\end{align*}
hold.
\end{defn}

\begin{defn}
Let $A$ and $B$ be types. We define the \define{disjoint sum} $A+B$ to be a type that comes equipped with
\begin{align*}
\inl & : A \to A+B \\
\inr & : B \to A+B
\end{align*}
satisfying the induction principle that for any type family $P:(A+B)\to\type$, there is a term
\begin{equation*}
\ind{A+B} : \Big(\prd{x:A}P(\inl(x))\Big)\to\Big(\prd{y:B}P(\inr(y))\Big)\to\prd{z:A+B}P(z)
\end{equation*}
for which the computation rules
\begin{align*}
\ind{A+B}(f,g,\inl(x)) & \jdeq f(x) \\
\inr{A+B}(f,g,\inr(y)) & \jdeq g(y)
\end{align*}
hold.
\end{defn}

\section{The type of integers}
\begin{defn}
We define the \define{integers} to be the type $\Z\defeq\nat_{\geq 1}+\unit+\nat_{\geq 1}$.
\end{defn}

\begin{defn}
We construct a successor function $S:\Z\to\Z$.
\end{defn}

\begin{constr}

\end{constr}

\section{Dependent pair types}

\begin{defn}
Let $A$ be a type, and let $P:A\to\type$ be a type family over $A$.
The \define{dependent pair type} $\sm{x:A}P(x)$ is defined to be a type equipped with a \define{pairing function}
\begin{equation*}
\pairr{\blank,\blank}:\prd{x:A} P(x)\to \Big(\sm{y:A}P(y)\Big)
\end{equation*}
and \define{projection maps}
\begin{align*}
\proj 1 & : \Big(\sm{x:A}P(x)\Big)\to A \\
\proj 2 & : \prd{w:\sm{x:A}P(x)}P(\proj 1(w))
\end{align*}
satisfying the equations
\begin{align*}
\proj 1(\pairr{a,p}) & \jdeq a \tag{$\beta_1$}\\
\proj 2(\pairr{a,p}) & \jdeq p \tag{$\beta_2$}\\
\pairr{\proj 1(w),\proj 2(w)} & \jdeq w. \tag{$\eta$}
\end{align*}
\end{defn}

\begin{exercises}
\item For any type $A$, show that $(A+\neg A)\to(\neg\neg A\to A)$. 
\item \label{ex:int_group_ops}Define operations $k,l\mapsto k+l:\Z\to\Z\to\Z$ and $k\mapsto -k:\Z\to \Z$.
\item \label{ex:int_order}Define the relations $\leq$ and $<$ on and $\Z$.
\end{exercises}

\chapter{Inductive types}

\section{The idea of inductive types}

Many other types can also be specified as inductive types, similar to the natural numbers. The unit type, the empty type, and the booleans are the simplest examples of this way of defining types. Just like the type of natural numbers, other inductive types are also specified by their \emph{constructors}, an \emph{induction principle}, and their \emph{computation rules}: 
\begin{enumerate}
\item The constructors tell what structure the inductive type comes equipped with. There may be multiple constructors, or no constructors at all in the specification of an inductive type. 
\item The induction principle specifies the data that should be provided in order to construct a section of an arbitrary dependent type over the inductive type. 
\item The computation rules assert that the inductively defined section agrees on the constructors with the data that was used to define the section. Thus, there is a computation rule for every constructor.
\end{enumerate}
For a more general treatment of inductive types, we refer to Chapter 5 of \cite{hottbook}.
\begin{defn}
We define the \define{unit type} to be a type $\unit$ equipped with
\begin{equation*}
\ttt:\unit,
\end{equation*}
satisfying the induction principle that for any type family $P:\unit\to\type$, there is a term
\begin{equation*}
\ind{\unit} : P(\ttt)\to\prd{x:\unit}P(x)
\end{equation*}
for which the computation rule
\begin{equation*}
\ind{\unit}(p_{\ttt},\ttt) \jdeq p_\ttt
\end{equation*}
holds.
\end{defn}

The empty type is a degenerate example of an inductive type. It does \emph{not} come equipped with any constructors, and therefore there are also no computation rules. The induction principle merely asserts that any type family has a section.
\begin{defn}
We define the \define{empty type} to be a type $\emptyt$ satisfying the induction principle that for any type family $P:\emptyt\to\type$, there is a term
\begin{equation*}
\ind{\emptyt} : \prd{x:\emptyt}P(x).
\end{equation*}
\end{defn}

\begin{defn}
We define the \define{booleans} to be a type $\bool$ that comes equipped with
\begin{align*}
\bfalse & : \bool \\
\btrue & : \bool
\end{align*}
satisfying the induction principle that for any type family $P:\bool\to\type$, there is a term
\begin{equation*}
\ind{\bool} : P(\bfalse)\to P(\btrue)\to \prd{x:\bool}P(x)
\end{equation*}
for which the computation rules
\begin{align*}
\ind{\bool}(p_0,p_1,\bfalse) & \jdeq p_0 \\
\ind{\bool}(p_0,p_1,\btrue) & \jdeq p_1
\end{align*}
hold.
\end{defn}

\begin{defn}
Let $A$ and $B$ be types. We define the \define{disjoint sum} $A+B$ to be a type that comes equipped with
\begin{align*}
\inl & : A \to A+B \\
\inr & : B \to A+B
\end{align*}
satisfying the induction principle that for any type family $P:(A+B)\to\type$, there is a term
\begin{equation*}
\ind{A+B} : \Big(\prd{x:A}P(\inl(x))\Big)\to\Big(\prd{y:B}P(\inr(y))\Big)\to\prd{z:A+B}P(z)
\end{equation*}
for which the computation rules
\begin{align*}
\ind{A+B}(f,g,\inl(x)) & \jdeq f(x) \\
\inr{A+B}(f,g,\inr(y)) & \jdeq g(y)
\end{align*}
hold.
\end{defn}

\section{The type of integers}
\begin{defn}
We define the \define{integers} to be the type $\Z\defeq\nat_{\geq 1}+\unit+\nat_{\geq 1}$.
\end{defn}

\begin{defn}
We construct a successor function $S:\Z\to\Z$.
\end{defn}

\begin{constr}

\end{constr}

\section{Dependent pair types}

\begin{defn}
Let $A$ be a type, and let $P:A\to\type$ be a type family over $A$.
The \define{dependent pair type} $\sm{x:A}P(x)$ is defined to be a type equipped with a \define{pairing function}
\begin{equation*}
\pairr{\blank,\blank}:\prd{x:A} P(x)\to \Big(\sm{y:A}P(y)\Big)
\end{equation*}
and \define{projection maps}
\begin{align*}
\proj 1 & : \Big(\sm{x:A}P(x)\Big)\to A \\
\proj 2 & : \prd{w:\sm{x:A}P(x)}P(\proj 1(w))
\end{align*}
satisfying the equations
\begin{align*}
\proj 1(\pairr{a,p}) & \jdeq a \tag{$\beta_1$}\\
\proj 2(\pairr{a,p}) & \jdeq p \tag{$\beta_2$}\\
\pairr{\proj 1(w),\proj 2(w)} & \jdeq w. \tag{$\eta$}
\end{align*}
\end{defn}

\section{The universe}
We assume there is a closed type $\UU$ called the \define{universe}, and a type family $\mathrm{El}$ over $\UU$ called the \define{universal family}.
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\vdash\UU~\mathrm{type}$}
\end{prooftree}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$X:\UU \vdash \mathrm{El}(X)~\mathrm{type}$}
\end{prooftree}

The universe is useful for several reasons.
We will postulate that the universe is closed under most type forming operations (with the exception that we will not assume that the universe contains a universe), and this enables us to use type theory itself to study type theory.
Thus, we postulate the following rules asserting closure under $\Pi$:
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$A:\UU,B:\mathrm{El}(A)\to\UU \vdash \check{\Pi}(A,B):\UU$}
\end{prooftree}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$A:\UU,B:\mathrm{El}(A)\to\UU \vdash \mathrm{El}(\check{\Pi}(A,B))\jdeq \prd{x:\mathrm{El}(A)}\mathrm{El}(B(x))~\mathrm{type}$}
\end{prooftree}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\vdash \check{\N}:\UU$}
\end{prooftree}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\vdash \mathrm{El}(\check{\N})\jdeq \mathbb{N}~\mathrm{type}$}
\end{prooftree}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\vdash \check{\emptyt}:\UU$}
\end{prooftree}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\vdash \mathrm{El}(\check{\emptyt})\jdeq \emptyt~\mathrm{type}$}
\end{prooftree}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\vdash \check{\unit}:\UU$}
\end{prooftree}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\vdash \mathrm{El}(\check{\unit})\jdeq \unit~\mathrm{type}$}
\end{prooftree}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$A:\UU,B:\mathrm{El}(A)\to\UU \vdash \check{\Sigma}(A,B):\UU$}
\end{prooftree}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$A:\UU,B:\mathrm{El}(A)\to\UU \vdash \mathrm{El}(\check{\Sigma}(A,B))\jdeq \sm{x:\mathrm{El}(A)}\mathrm{El}(B(x))~\mathrm{type}$}
\end{prooftree}

The idea of the universe is that it is a type of \emph{small} types. Indeed, given a closed term $A:\UU$ we also obtain the closed type $\mathrm{El}(A)$ of its \define{elements}, so the term $A:\UU$ is an \emph{encoding} of the type $\mathrm{El}(A)$. 

\begin{defn}
We say that a type $A$ in context $\Gamma$ is \define{small} if it occurs in the universe, i.e.~if there is a term $\check{A}:\UU$ in context $\Gamma$ such that $\Gamma\vdash\mathrm{El}(\check{A})\jdeq A~\mathrm{type}$.
\end{defn}

In particular, if $A$ is a small type in context $\Gamma$ and $B$ is a small type in context $\Gamma,x:A$, then $\prd{x:A}B(x)$ is again a small type in context $\Gamma$.

\begin{defn}
Let $A$ be a type in context $\Gamma$. A \define{family of small types} over $A$ is defined to be a map
\begin{equation*}
B:A\to\UU
\end{equation*}
\end{defn}

In particular, we see that we can use the rules for function types to define families of small types. More to the point: one of the ways in which a universe is useful is that it provides us with a way to define new type families. Another way in which the universe can be useful is that the universe can occur in a context (so constructions in type theory can have occurences of `type-varialbes').

\begin{rmk}
If $A$ is small, we usually write simply $A$ for $\check{A}$ and also $A$ for $\mathrm{El}(\check{A})$. In other words, by $A:\UU$ we mean that $A$ is a small type. 
\end{rmk}

\begin{exercises}
\item For any type $A$, show that $(A+\neg A)\to(\neg\neg A\to A)$. 
\item \label{ex:int_group_ops}Define operations $k,l\mapsto k+l:\Z\to\Z\to\Z$ and $k\mapsto -k:\Z\to \Z$.
\item \label{ex:int_order}Define the relations $\leq$ and $<$ on and $\Z$.
\item Construct a closed term of type
\begin{equation*}
\prd{A:\UU}\Big(\prd{X:\UU}X\Big)\to A.
\end{equation*}
\item Define the relations $\leq$ and $<$ on $\N$.
\item Define the divisibility relation $d\mid n$. 
\end{exercises}

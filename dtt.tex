\chapter{Dependent type theory}

\section{Structures, contexts, and hypotheses in mathematical practice}
To illustrate the concept of type dependency, let us have a closer look at the anatomy of the following purposefully simple lemma.

\begin{lem}\label{lem:unit}
Given a binary operation $\mu:A\times A\to A$ on a set $A$, any $u_l\in A$ satisfying satisfying the left unit law $\mu(u_l,x)=x$, and any $u_r\in A$ satisfying the right unit law $\mu(x,u_r)=x$, one has $u_l=u_r$. 
\end{lem}

\begin{proof}
Since $u_l$ is a left unit, we have in particular $u_l=\mu(u_l,u_r)$. Furthermore, since $u_r$ is a right unit we have in particular $\mu(u_l,u_r)=u_r$. Thus, we have $u_l=\mu(u_l,u_r)=u_r$. 
\end{proof}

By the hypotheses of \autoref{lem:unit}, we start the proof with the following set of presuppositions:
\begin{align*}
A & : \mathbf{Set} \\
\mu & : A\times A\to A \\
u_l & : A \\
p & : \forall x.\,\mu(u_l,x)=x\\
u_r & : A \\
q & : \forall x.\,\mu(x,u_r)=x,
\end{align*}
and the task is to show that $u_l=u_r$.
This list of assumptions is called the \define{context} of our proof. A context is always a finite list, declaring the structure we are working with. In principle, one could give such a finite list of presumed structure for any mathematical text at any position in the text.

Contexts are lists of variable declarations. The variable can have any type, and the type of a variable may depend on previous variables.
Note that in the case at hand, the list also contains two \emph{properties}: the left and right unit laws. 
From a logical perspective propositions are the types of their proofs.
In particular, the left and right unit laws are also considered to be types.

The type $\set$ is a type of all \emph{small} sets.
Just as in set theory, assuming that there is a type of all sets would lead to contradictions, but it is okay to assume that there is a type of some sets, whithout assuming that this is the type of all sets.
In fact, we will be assuming that there is a type $\UU$ of \emph{small} types.

\section{Type dependency}

The theory of type dependency is formulated as a deductive system in which derivations establish that a given construction is well-formed. In any dependent type theory there are three kinds of judgments:
\begin{enumerate}
\item `\emph{$\Gamma$ is a well-formed context.}'
\item `\emph{$A$ is a well-formed type in context $\Gamma$.}'
\item `\emph{$a$ is a well-formed term of type $A$ in context $\Gamma$.}'
\end{enumerate}
Along with those judgments there are also judgments establishing the equality of contexts, types and terms.
Thus, the basic judgments of type theory are as follows:
\begin{align*}
& \vdash \Gamma~\mathrm{ctx} & & \vdash \Gamma\jdeq \Gamma'~\mathrm{ctx} \\
\Gamma & \vdash A~\mathrm{type} & \Gamma & \vdash A\jdeq A'~\mathrm{type}\\
\Gamma & \vdash a:A & \Gamma & \vdash a\jdeq a':A.
\end{align*}
We say that a context is well-formed if it is of the form
\begin{equation*}
x_1:A_1,~x_2:A_2,~\ldots,~x_n:A_n
\end{equation*}
where for each $1\leq k\leq n$ we have that $A_k$ is a well-formed type in context $x_1:A_1,x_2:A_2,\ldots,x_{k-1}:A_{k-1}$, i.e.
\begin{equation*}
x_1:A_1,x_2:A_2,\ldots,x_{k-1}:A_{k-1} \vdash A_k~\mathrm{type}.
\end{equation*}
In the special case where $n=0$, the list $x_1:A_1,x_2:A_2,\ldots,x_n:A_n$ is empty, so this context is vacuously well-formed.

\begin{comment}
Note that any well-formed type $B$ in context $\Gamma$ determines the a new well-formed type $A$ in context $\Delta$ (sometimes called the \emph{father} of $B$), so that 
\begin{equation*}
\vdash \Delta,x:A\jdeq \Gamma~\mathrm{ctx},
\end{equation*}
and so on until one reaches the empty context. 
This happens in a finite number of steps, and the number of steps it takes to reach the empty context in this way is called the \emph{dependency level} of $A_k$. 

If we collect all the types of dependency level $k$ in a class $T_k$, and all their terms in a class $\tilde{T}_k$, we see that type dependency is a structure of the form
\begin{equation*}
\begin{tikzcd}
\tilde{T}_3 \arrow[dr,"\partial"] & \vdots \arrow[d,"\mathrm{ft}"] \\
\tilde{T}_2 \arrow[dr,"\partial"] & T_3 \arrow[d,"\mathrm{ft}"] \\
\tilde{T}_1 \arrow[dr,"\partial"] & T_2 \arrow[d,"\mathrm{ft}"] \\
& T_1
\end{tikzcd}
\end{equation*}
Types at dependency level $1$ are called \define{closed types}, and terms at dependency level $1$ are called \define{closed terms}.
\end{comment}

\section{Structural rules of type theory}

The structural rules for type dependency are rules for \emph{weakening} and \emph{substitution}, that describe the basic operations one can perform on dependent types. Along with the weakening and substitution rules there is also the \emph{variable rule}, which postulates that $x$ is a term of type $A$ in context $\Gamma,x:A$.

\bigskip
\begin{minipage}{.45\textwidth}
\begin{prooftree}
\AxiomC{$\Gamma\vdash A~\mathrm{type}$}
\AxiomC{$\Gamma,\Delta\vdash B~\mathrm{type}$}
\RightLabel{$W$}
\BinaryInfC{$\Gamma,x:A,\Delta \vdash B~\mathrm{type}$}
\end{prooftree}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{prooftree}
\AxiomC{$\Gamma\vdash A~\mathrm{type}$}
\AxiomC{$\Gamma,\Delta\vdash b:B$}
\RightLabel{$\tilde{W}$}
\BinaryInfC{$\Gamma,x:A,\Delta \vdash b:B$}
\end{prooftree}
\end{minipage}

\noindent
\begin{prooftree}
\AxiomC{$\Gamma\vdash A~\mathrm{type}$}
\RightLabel{Var}
\UnaryInfC{$\Gamma,x:A\vdash x:A$}
\end{prooftree}

\noindent
\begin{minipage}{.5\textwidth}
\begin{prooftree}
\AxiomC{$\Gamma\vdash a:A$}
\AxiomC{$\Gamma,x:A,\Delta\vdash B~\mathrm{type}$}
\RightLabel{$S$}
\BinaryInfC{$\Gamma,\Delta[a/x]\vdash B[a/x]~\mathrm{type}$}
\end{prooftree}
\end{minipage}\hfill
\begin{minipage}{.5\textwidth}
\begin{prooftree}
\AxiomC{$\Gamma\vdash a:A$}
\AxiomC{$\Gamma,x:A,\Delta\vdash b:B$}
\RightLabel{$\tilde{S}$}
\BinaryInfC{$\Gamma,\Delta[a/x]\vdash b[a/x] : B[a/x]$}
\end{prooftree}
\end{minipage}

\bigskip
In these rules, the context $\Delta$ is of the form $x_{n+1}:A_{n+1},\ldots,x_{n+m}:A_{n+m}$.
The expression $\Delta[a/x]$ is just an abbreviation for the expression
\begin{equation*}
x'_n:A_{n+1}[a/x],\ldots,x'_{n+m-1}:A_{n+m}[a/x]
\end{equation*}
and the expression $A_{n+i}[a/x]$ is an abbreviation for the expression
\begin{equation*}
A_{n+i}(x_1,\ldots,x_{n-1},a,x'_n,\ldots,x'_{n+i-1}).
\end{equation*}

\begin{comment}
For $A\in T_n$ we define $T_{n+k+1}(A):= \{B\in T_{n+k}\mid \mathrm{ft}^{k+1}(B)=A\}$. Similarly we define $\tilde{T}_{n+k+1}(A):=\{b\in\tilde{T}_{n+k+1}\mid\mathrm{ft}^{k+1}(\partial(b))=A\}$. For any closed type $A$ we maintain the convention that $T_{k}(\mathrm{ft}(A)):= T_k$.
\begin{enumerate}
\item For all $A\in T_n$, and all $k\in\N$, \define{weakening} operations
\begin{align*}
W_A & : T_{n+k}(\mathrm{ft}(A)) \to T_{n+k+1}(A) \\
\tilde{W}_A & : \tilde{T}_{n+k}(\mathrm{ft}(A))\to \tilde{T}_{n+k+1}(A)
\end{align*}
subject to the conditions $\mathrm{ft}(W_A(B))=W_A(\mathrm{ft}(B))$ if $B\in T_{n+k}$ with $k\geq 1$, and $\partial(\tilde{W}_A(b))=W_A(\partial(b))$.
\item For all $A\in T_n$ a term $\delta_A\in \tilde{T}_{n+1}$ satisfying $\partial(\delta_A)=W_A(A)$. 
\item For all $a\in \tilde{T}_n$ satisfying $\partial(a)=A$, and all $k\in\N$, \define{substitution} operations
\begin{align*}
S_a & : \{B\in T_{n+k+1}\mid \mathrm{ft}^{k+1}(B)= A\}\to T_k \\
\tilde{S}_a & : \{b\in \tilde{T}_{n+k+1}\mid \mathrm{ft}^{k+1}(\partial(b))=A\}\to \tilde{T}_{n+k}
\end{align*}
subject to the conditions $\mathrm{ft}(S_a(B))=\mathrm{ft}(A)$ if $B\in T_{n+1}$, $\mathrm{ft}(S_a(B))=S_a(\mathrm{ft}(B))$ if $B\in T_{n+k+1}$ with $k\geq 1$, and $\partial(\tilde{S}_a(b))=S_a(\partial(b))$.
\end{enumerate}
\end{comment}

%\section{Axioms for weakening, substitution, and the diagonal}
\begin{comment}
\begin{prooftree}
\AxiomC{$\Gamma\vdash A~\mathrm{type}$}
  \AxiomC{$\Gamma,x:A,\Delta\vdash B~\mathrm{type}$}
    \AxiomC{$\Gamma,x:A,\Delta,y:B,E\vdash C~\mathrm{type}$}
\TrinaryInfC{$\Gamma,\Delta[a/x],E[b/y][a/x]\vdash C[b/y][a/x]\jdeq C[a/x][b[a/x]/y']~\mathrm{type}$}
\end{prooftree}
\begin{prooftree}
\AxiomC{$\Gamma\vdash A~\mathrm{type}$}
  \AxiomC{$\Gamma,x:A,\Delta\vdash B~\mathrm{type}$}
    \AxiomC{$\Gamma,x:A,\Delta,y:B,E\vdash c:C$}
\TrinaryInfC{$\Gamma,\Delta[a/x],E[b/y][a/x]\vdash c[b/y][a/x]\jdeq c[a/x][b[a/x]/y']:C[b/y][a/x]$}
\end{prooftree}
\begin{prooftree}
\AxiomC{$\Gamma\vdash a:A$}
  \AxiomC{$\Gamma,\Delta\vdash B~\mathrm{type}$}
\RightLabel{($x$ not free in $B$)}
\BinaryInfC{$\Gamma,\Delta\vdash B[a/x]\jdeq B~\mathrm{type}$}
\end{prooftree}
\end{comment}
\begin{enumerate}
\item Given a type $A$ in context $\Gamma$, and a type $B$ in context $\Gamma,\Delta$, we can weaken twice by first weakening by $B$ and then by $A$, as indicated in the following derivation:
\begin{prooftree}
\AxiomC{$\Gamma\vdash A~\mathrm{type}$}
\AxiomC{$\Gamma,\Delta\vdash B~\mathrm{type}$}
  \AxiomC{$\Gamma,\Delta,\mathrm{E}\vdash \mathcal{J}$}
\BinaryInfC{$\Gamma,\Delta,y:B,\mathrm{E}\vdash \mathcal{J}$}
\BinaryInfC{$\Gamma,x:A,\Delta,y:B,\mathrm{E}\vdash \mathcal{J}$}
\end{prooftree}
However, we can also first weaken by $A$, and then by `$B$ weakened by $A$', as indicated in the following derivation:
\begin{prooftree}
\AxiomC{$\Gamma\vdash A~\mathrm{type}$}
  \AxiomC{$\Gamma,\Delta\vdash B~\mathrm{type}$}
\BinaryInfC{$\Gamma,x:A,\Delta\vdash B~\mathrm{type}$}
  \AxiomC{$\Gamma\vdash A~\mathrm{type}$}
    \AxiomC{$\Gamma,\Delta,\mathrm{E}\vdash \mathcal{J}$}
  \BinaryInfC{$\Gamma,x:A,\Delta,\mathrm{E}\vdash \mathcal{J}$}
\BinaryInfC{$\Gamma,x:A,\Delta,y:B,\mathrm{E}\vdash \mathcal{J}$}
\end{prooftree}
For the end result it does not matter in what order the two weakenings are performed.
%We can express this clearly when we have explicit notation for the weakening operations: for all $A\in T_n$ and $B\in T_{n+k}(\mathrm{ft}(A))$, one has
%\begin{align*}
%W_A(W_B(C)) & = W_{W_A(B)}(W_A(C)) \tag{$C\in T_{n+k+m}(\mathrm{ft}(B))$}\\
%\tilde{W}_A(\tilde{W}_B(c)) & = \tilde{W}_{W_A(B)}(\tilde{W}_A(c)). \tag{$c\in\tilde{T}_{n+k+m}(\mathrm{ft}(B))$}
%\end{align*}
\item For all $a\in\tilde{T}_n$ and $b\in\tilde{T}_{n+k}$, one has
\begin{align*}
S_a(S_b(C)) & = S_{\tilde{S}_a(b)}(S_a(C)) & & & (C\in T_{n+k+m}) \\
\tilde{S}_a(\tilde{S}_b(c)) & = \tilde{S}_{\tilde{S}_a(b)}(\tilde{S}_a(c)). & & & (c\in\tilde{T}_{n+k+m})
\end{align*}
\end{enumerate}

\begin{exercises}
\item Give prooftrees
\end{exercises}
